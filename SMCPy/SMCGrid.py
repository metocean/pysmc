#!/usr/bin/env python
# -*- coding: utf-8 -*-
# File              : SMCGrid.py
# Author            : Qingxiang Liu
# Date              : 03.17.2015
# Last Modified Date: 07.11.2017
# Last Modified By  : Tom Durrant <t.durrant@metocean.co.nz>
# -*- coding: utf-8 -*-

"""
SMCGridGen.py

Author            : Qingxiang Liu

Date              : Thu Aug 20 2015 [Generate bathy array from etopo file]
Mod   : Sat Oct 17 2015 [Generate bathy/obst from ww3 gridgen Matlab package]
Mod   : add a `buoy_list` argument to the GenSMCGrid function.
Mod   : Sun Jan 24 2016 [Global SMC grid]
Mod   : Tom Durrant -  Oct 2017 Added refining based on depth
Mod   : Tom DUrrant -  Oct 2017 Added face array generation methods baesd no
                       Jian-Gou's fortran code
Mod   : Tom DUrrant -  Added exclusions based on user supplied polygons
                       (similar to grigen)

Note:
1) WW3 traditional lon-lat grid: grid/node registered
   SMC grid: cell/pixel registered
   --> The regular WW3 grid should correspond to the cell center of SMC base level
       grid (i.e., size 4 cell). Each smc grid base resolution cell has a
       corresponding regular grid cell, at exactly the same center point.

   --> That is the exact meaning of the match between SMC and LLG

2) dlon, dlat of SMC size-1 cell should be specified reasonably. For example,
   SMC625 grid -- dlon = (360./1024) / 4 & dlat = (180./768) / 4 (~6km)
   SMC416 grid -- dlon = (360./1536) / 4 & dlat = (180./1152) / 4 (~4km)

3) Use `double` type for real array & `long` type for integer array

4) There are minor differences between global and regional models:
   a. the polar cell [the last four rows]
      deltax for polar cell should be the same as that of those cells around it.

      For SMC4816 grid, there are 360/dlon = 6144 cells in the meridional
      direction and the north polar cell is finally surrounded by 6 cells, so
      its deltax = 6144 / 6.

   b. the start & end index of i, j
   c. wrap around 360 degree
   d. args `globe` and `Arctic` are used to manage different cases

5) When we merge cells based on bathymetry, we would use several other cells
   around the given cell. When we generate bathymetry array from Gridgen, please
   assure the grid_box for our bathy data is a little larger than the region
   we are really instrested in

7) Technically, any points can be used as reference point. But we should try
   our best to use (0, 0) as the reference point when we design global domain.

8) the level of cell size must change smoothly, i.e., size-1 --> 2 --> 4.
   For practical usage, normally size1_bbox < size2_bbox < size4_bbox

9) To speed up this script, several collections of matplotlib are used:
   PolyCollection for cells
   Scatter for cell center [only used for depth plot, s should be very small]

   mpl scatter function gives markers of which size is based on pixel. Because
   of this, marker size will look different in screen display from those in
   png/pdf figure. So Circle patch collection can be used to fix this problem.
   [But slow down and increase the size of pdf figure significantly.]
"""
###############################################################
# -- m. modules
import os
import datetime
from collections import OrderedDict

import cartopy.crs as ccrs
import cartopy.feature as cfeature

import numpy as np
import pandas as pd
import scipy.io as sio
from tqdm import tqdm
import logging
import cmocean
import cPickle
import xarray as xr

import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker
from matplotlib.patches import Circle
from matplotlib.path import Path # Path is much faster than Shapely
from matplotlib.collections import PolyCollection, PatchCollection
from mpl_toolkits.axes_grid1.inset_locator import inset_axes

import SMCPy

#import sys; sys.path.append(r'/media/qliu/Zuoer_dream/mylib')
#from pyutil.colors import gen_cmap, ct10
from colors import gen_cmap, ct10
proj = ccrs.Robinson(central_longitude=180.)


# Set grid extents for global and regional grids
glob_icol_beg, glob_icol_end = 0, -4
glob_jrow_beg, glob_jrow_end = 4, -8
reg_icol_beg, reg_icol_end = 2, -6
reg_jrow_beg, reg_jrow_end = 2, -6


###############################################################
class MatBathy(object):
    def __init__(self, fnm, debug=None):
        """
        MatBathy Class

        Read Mat file generated by ww3 gridgen (v2.1), including:
        --------------------------------------------------------
        dlon -- resolution in x direction
        dlat -- resolution in y direction
        lon -- 1d array [longitude of size-1 cell center/grid node]
        lat -- 1d array [latitude of size-1 cell center/grid node]
        depth -- 2d array [bathymetry with the land point being 1 m]
        m2 -- 2d array [generated by clean_mask function; mask]
              land: 0, sea: 1
        m3 -- 2d array [generated by remove_lake function; mask]
              largest water body: 1, other area: 0
        mask_map -- 2d array [generated by remove_lake function; water body]
              land: -1, water body: 1 --> N
        sx -- 2d array [obstruction in x dirc.] 0: transparent, 1: block
        sy -- 2d array [obstruction in y dirc.]

        Input args:
        ----------- For __init__:
        fnm -- name of the mat file genarted by gridgen
        debug -- True or False. If true, more verbose infor. will be printed
                 to stdout. Any non-null/zero value will be regarded as True
        """
        self.fnm = fnm
        self.load_file()

        # -- change sx, sy (* 100)
        self.sx1 *= 100
        self.sy1 *= 100

        # -- change lon, lat to 1d arrays
        self.lon = self.lon[0,:]
        self.lat = self.lat[:,0]

        self._genInfo()

        # -- refine the bathy/depth data [only retain the largest water body]
        # -- Modify here if you need retain other watet bodies.
        self.depth = np.where(np.equal(self.m4, 1), self.depth, 1.)

        if debug:
            print
            print '**** [Bathy size-1] {:s} ****'.format(self.gid.upper())
            print 'globe [Y/N]:', self.globe
            print 'nrow, ncol (nlat, nlon):', self.nrow, self.ncol
            print 'dlon, dlat:', self.dlon, self.dlat
            print 'zlon, zlat:', self.zlon, self.zlat
            print 'flon, flat:', self.flon, self.flat
            print 'elon, elat:', self.lon[-1], self.lat[-1]
            print 'min/max depth:', self.depth.min(), self.depth.max()
            print
            print '**** [WW3 Grid Inp] ****'
            print 'DX, DY:', self.ww3_grid['DX'], self.ww3_grid['DY']
            print 'X1, Y1:', self.ww3_grid['X1'], self.ww3_grid['Y1']
            print 'NX, NY:', self.ww3_grid['NX'], self.ww3_grid['NY']
            print 'XE, YE:', self.ww3_grid['XE'], self.ww3_grid['YE']

    def load_file(self):
        """ load in mat file generated by gridgen"""
        self.gid = os.path.basename(self.fnm)[:-4]
        matDict = sio.loadmat(self.fnm, squeeze_me=True)
        keys = ['dlon', 'dlat', 'lon', 'lat', 'depth', 'm3', 'm4', 'mask_map',
                'sx1', 'sy1']
        for key in keys:
            setattr(self, key, matDict[key])
        del keys, matDict

    def _genInfo(self):
        """
        Generate basic grid infor. for both size-1 and base level (used in
        ww3_grid.inp)
        """
        # -- for size 1 [used to generate SMC]
        if (np.equal((self.lon[-1] - self.lon[0]), (360. - self.dlon)) or
           np.equal((self.lon[-1] - self.lon[0]), (360.))):
            self.globe=True
        else:
            self.globe=False
        if self.globe:
            self.icol_beg, self.icol_end = glob_icol_beg, glob_icol_end
            self.jrow_beg, self.jrow_end = glob_jrow_beg, glob_jrow_end
        else:
            self.icol_beg, self.icol_end = reg_icol_beg, reg_icol_end
            self.jrow_beg, self.jrow_end = reg_jrow_beg, reg_jrow_end

        self.flon = self.lon[0]
        self.flat = self.lat[0]
        self.flon_reduced = self.lon[self.icol_beg]
        self.flat_reduced = self.lat[self.jrow_beg]
        self.zlon = self.flon - self.dlon * .5 # lon of s-w corner
        self.zlat = self.flat - self.dlat * .5 # lat of s-w corner
        self.zlon_reduced = self.zlon + self.icol_beg * self.dlon
        self.zlat_reduced = self.zlat + self.jrow_beg * self.dlat
        self.nrow = self.lat.size
        self.ncol = self.lon.size

        # -- for base level (size-4) [used in ww3_grid.inp]
        # -- NX, NY and XE, YE probably need be adjust for global simulation.
        self.ww3_grid = OrderedDict()
        self.ww3_grid['DX'] = self.dlon*4
        self.ww3_grid['DY'] = self.dlat*4
        self.ww3_grid['X1'] = self.zlon_reduced + (0.5 * self.dlon)
        self.ww3_grid['Y1'] = self.zlat_reduced + (0.5 * self.dlat)
        self.ww3_grid['NX'] = np.floor((self.lon[self.icol_end]-self.zlon_reduced) / (self.dlon*4)
                                      ).astype('i') + 1
        self.ww3_grid['NY'] = np.floor((self.lat[self.jrow_end]-self.zlat_reduced) / (self.dlat*4)
                                      ).astype('i') + 1
        self.ww3_grid['XE'] = self.ww3_grid['X1'] + (self.ww3_grid['NX']-1) * (
                              self.dlon*4)
        self.ww3_grid['YE'] = self.ww3_grid['Y1'] + (self.ww3_grid['NY']-1) * (
                              self.dlat*4)

class PyBathy(MatBathy):

    def load_file(self):
        """ load in pickle file generated by pygridgen """
        self.gid = os.path.basename(self.fnm)[:-4]
        pyDict = cPickle.load(open(self.fnm, "rb"))
        keys = ['dlon', 'dlat', 'lon', 'lat', 'depth', 'm3', 'm4', 'mask_map',
                'sx1', 'sy1']
        for key in keys:
            setattr(self, key, matDict[key])
        del keys, matDict

class NCBathy(MatBathy):

    def load_file(self):
        """ load in nc file generated externally """
        self.gid = os.path.basename(self.fnm)[:-3]
        data = xr.open_dataset(self.fnm)
        self.depth = data.z.values
        self.lon, self.lat = np.meshgrid(data.lon.values % 360.,
                                         data.lat.values)
        # m3 and m4 are just placeholders for now. There are used to remove
        # lakes and small bodies of water. This can be done here using exlude
        # polygons, but might be worth considering implementing this in gridgen
        # way at some point
        self.m3 = np.ones_like(self.depth)
        self.m4 = np.ones_like(self.depth)
        self.mask_map = np.ones_like(self.depth)
        self.sx1 = np.zeros_like(self.depth)
        self.sy1 = np.zeros_like(self.depth)
        self.dlon = data.lon[1].values - data.lon[0].values
        self.dlat = data.lat[1].values - data.lat[0].values
        del data


###############################################################
# -- Island class
class Island(object):
    """
    Island Class

    Refine unresovled islands in the bathy array, that is, turn some inaccurate
    sea points w/o its neighbour points to be land.

    Note: this class can also be used to refine lp_map around buoys. For eg.,
          if you want increase the resolution in vincity of one given buoy,
          just find the index and let lp_map to be 1 or 2.

    Input args:
    --------- For __init__
        name -- string of the island

        lon & lat -- location of this island

        relneigh -- relative neighbour points around this island to be filled.
                    [a list of relative index].

        bthrd -- number of points around buoys to be refined.

        nrow/ncol -- nlat/nlon for bounds check

        Suppose we want to fill three cells center at Huangyang Island,
        relneigh should be somethings like [[-1, 0], [0, 0], [-1, 1]]

    --------- For absneigh
        zlon & zlat & dlon & dlat -- the arributes of bathy object
    """
    def __init__(self, name=None, lon=None, lat=None, relneigh=None,
                 bthrd=None):

        self.name = name if name is not None else 'island'
        self.lon = lon
        self.lat = lat
        self.relneigh = relneigh
        self.bthrd = bthrd

    def absneigh(self, zlon=None, zlat=None, dlon=None, dlat=None,
                 nrow=None, ncol=None):

        # -- get index of lon & lat
        isl_i = long(np.floor((self.lon-zlon) / dlon)) # floor
        isl_j = long(np.floor((self.lat-zlat) / dlat))

        if self.relneigh is None:
            self.reneigh = [0, 0]

        if self.bthrd: # for buoy
            relind = np.arange(-self.bthrd, self.bthrd+1, 1)
            relx, rely = np.meshgrid(relind, relind)
            rad = np.hypot(relx, rely)
            loc1 = rad <= .5 * self.bthrd # size 1
            loc2 = (rad > .5 * self.bthrd) & (rad <= self.bthrd) # size 2
            self.relneigh = np.c_[rely[loc1], relx[loc1]] # rely[loc1] 1d
            self.relneigh2= np.c_[rely[loc2], relx[loc2]]

        self.relneigh = np.asarray(self.relneigh).reshape(-1, 2)
        absneigh = self.relneigh + np.array([[isl_j, isl_i]] * self.relneigh.shape[0])
        absneigh = absneigh.astype('l')
        loc = (absneigh[:, 0] < nrow) & (absneigh[:, 1] < ncol)
        absneigh = absneigh[loc]

        if not hasattr(self, 'relneigh2'):
            return absneigh
        else:
            self.relneigh2= np.asarray(self.relneigh2).reshape(-1, 2)
            absneigh2 = self.relneigh2 + np.array([[isl_j, isl_i]] * self.relneigh2.shape[0])
            absneigh2 = absneigh2.astype('l')
            loc = (absneigh2[:, 0] < nrow) & (absneigh2[:, 1] < ncol)
            absneigh2 = absneigh2[loc]

            return absneigh, absneigh2

###############################################################
def FindLevelLoc(size_bbox=None, lon1d=None, lat1d=None):
    """
    Locate all the points inside the `size_bbox`.

    Input args:
        size_bbox -- a rectangle or irregular polygon defining the extent of
                     one specific size/level

        lon1d & lat1d -- the x&y axis of bathy array (nlat x nlon)
    """
    size_bbox = np.asarray(size_bbox) # [lon, lat]
    size_path = Path(size_bbox)

    lon2d, lat2d = np.meshgrid(lon1d, lat1d)
    bathy_points = np.vstack((lon2d.ravel(),lat2d.ravel())).T

    inside = size_path.contains_points(bathy_points).reshape(lon2d.shape)

    return inside

###############################################################
# -- GenSMCGrid fuction
def GenSMCGrid(bathy_obj=None, island_list=None, refp=None, size2_bbox=None,
        size4_bbox=None, debug=True, land_value=1., ncel_thrd=10000000,
        buoy_list=None, arctic=False, gen_cell_sides=True,
        refining_depth=-250., exclude_flags=None):
    """
    Generate SMC 3 level grids.

    Input args:
        bathy_obj -- an instance of Bathy class, including attributes
            [nrow/nlat, ncol/nlon, flon, flat, dlon, dlat, zlon, zlat,
             lon, lat, depth, sx, sy] - see class `MatBathy` for detail.

        island_list -- a list of island objects needed to be resolved

        refp -- the reference point (lon, lat)
                Normally, we should use (0., 0.) or the s-w corner of the first
                base level cell (i.e., size-4).

                When we design global SMC grid, we must use zero longitude as
                reference.

        size[n]_bbox -- the rectangle/irregular polygons in which
                        size2/4 is preferred [Here we use matplotlib path
                        to test if points in polygon]
                        Here we don't use size-1 bbox. Size-1 cell is only
                        determined from sea points check or refinements through
                        Island class

        debug -- True / False / non-zero/null values
                 True/1 -- less detailed
                 2 -- more verbose

        land_value -- values for island/land bathy. [1 m]

        ncel_thrd -- the number used to intialize a cell array. For global
                     SMC grid, this number would be more than ~100000.

        buoy_list -- a list of buoys needed to be resolved with a high resolution
                     [using size-1 cell around these buoys]

        refining_depth -- If 0, refine grid based on land.
                          If > 0, refine based on this depth threshold

        exclude_flags -- Flag file for exluding predefined regions

    Note:
        In order to simplify the calculation in WW3, SMC grids should be
        strictly arranged as size-1-2-4 cells, that is, size 1 levels must
        be surrounded by size-2 cells. Similarly, size 4 levels must be
        surrounded by size-2 cells.

        Don't use buoy_list argument unless you are really clear about
        the effect of these islands and buoys on the level map.
    """
    # -- Refine un-resolved small islands
    if island_list is not None or buoy_list is not None:
        island_kwds = dict(zlon=bathy_obj.zlon_reduced, zlat=bathy_obj.zlat_reduced,
                           dlon=bathy_obj.dlon, dlat=bathy_obj.dlat,
                           nrow=bathy_obj.nrow, ncol=bathy_obj.ncol)

    if island_list is not None:
        island_index = np.array([[0, 0]], dtype='l') # Initialize

        for island in island_list:
            island_index = np.r_[island_index, island.absneigh(**island_kwds)]

        island_index = island_index[1:,:]

        if debug:
            print
            print "**** [SMCGrid] Resolve Island **"
            print "---- old values:"

            for (jnd, ind) in island_index:
                print jnd, ind, bathy_obj.depth[jnd, ind]


        bathy_obj.depth[island_index[:, 0], island_index[:, 1]] = land_value

    # -- check bathy data w/o island
    if debug:
        fig, ax = CartopyMap(proj, coast=True, figsize=(10, 4))
        mappable = ax.pcolormesh(bathy_obj.lon, bathy_obj.lat, bathy_obj.depth,
                     cmap=cmocean.cm.deep_r, transform=ccrs.PlateCarree())
        plt.colorbar(mappable)
        if island_list is not None:
            plt.plot(bathy_obj.lon[island_index[:, 1]],
                     bathy_obj.lat[island_index[:, 0]],
                     '+', ms=5, color='k', mew=1.)
        plt.title('Bathy')

    # -- refp: reference points [any point can be the reference point]
    #    for convenience, we should use (0, 0) or (zlon, zlat) of the bathy file
    #    the index for reference point is (0, 0)
    # refp_ww3grid = (bathy_obj.flon_reduced + (4*bathy_obj.dlon/2),
                    # bathy_obj.flat_reduced + (4*bathy_obj.dlat/2))

    # if refp is None: refp = (bathy_obj.ww3_grid['X1'],
                             # bathy_obj.ww3_grid['Y1'])
    if refp is None: refp = (bathy_obj.zlon_reduced,
                             bathy_obj.zlat_reduced)
    bathy_obj.refp = refp

    rx, ry = refp # reference point
    j0 = long(np.rint((refp[1] - ry) / bathy_obj.dlat)) # rint
    i0 = long(np.rint((refp[0] - rx) / bathy_obj.dlon))
    if debug:
        print
        print '**** [SMCGrid] index shift ****'
        print '---- reference point:', refp
        print '---- bathy zlon, zlat:', bathy_obj.zlon, bathy_obj.zlat
        print '---- globe [Y/N]:', bathy_obj.globe
        print '---- shift i0, j0:', i0, j0
        print

    # -- Row numbers of the merging parallels [Must be multiple of 4 rows]
    # -- Becasue size-4 are the basic cell
    parmrg = np.zeros(16, dtype='d')
    parmrg[8:] = np.array([60.000000, 75.522486, 82.819245, 86.416678,
                           88.209213, 89.104712, 89.552370, 89.776188])
    parmrg[:8] = -1 * parmrg[8:][::-1]

    jparmg = np.zeros(16, dtype='l') # floor
    jparmg = np.floor((parmrg - bathy_obj.zlat) / (bathy_obj.dlat * 4)) * 4
    jparmg = jparmg.astype('l')

    if debug:
        print
        print '**** [SMCGrid] Merging parallels and index ****'
        print '---- parallels:\n', parmrg
        print '---- index:\n', jparmg
        print

    # -- Intialize a level priority map [with the same shape of bathy]
    # -- the default preferred level for every nodes/cells is 4
    # -- Legend for this map:
    # -- 1/2/4 for size-1/2/4, and -1 for exculded values
    lp_map = np.ones_like(bathy_obj.depth, dtype='i1') * 4

    # -- points around buoy (size-1)
    if buoy_list is not None:
        island_index = np.array([[0, 0]], dtype='l') # Initialize
        island_index2= np.array([[0, 0]], dtype='l') # Initialize

        for island in buoy_list:
            temp_index, temp_index2 = island.absneigh(**island_kwds)
            island_index = np.r_[island_index, temp_index]
            island_index2= np.r_[island_index2, temp_index2]

        island_index = island_index[1:,:]
        island_index2 = island_index2[1:,:]

        lp_map[island_index[:, 0], island_index[:, 1]] = 1
        lp_val = lp_map[island_index2[:, 0], island_index2[:, 1]]
        lp_val = np.where(np.equal(lp_val, 4), 2, lp_val)
        lp_map[island_index2[:, 0], island_index2[:, 1]] = lp_val


    # -- kwds of FindLevelLoc
    fll_kwds = dict(lon1d=bathy_obj.lon, lat1d=bathy_obj.lat)

    if exclude_flags is not None:
        user_polys = np.loadtxt(exclude_flags, usecols=(0,1))
        fnumbers = user_polys[:,0][user_polys[:,1]==1]
        for f in fnumbers:
            p = np.loadtxt(os.path.join(os.path.dirname(SMCPy.__file__),
                                    "user_polygons/user_polygon-%s.txt" % int(f)))
            print("Removing polygon %s" % int(f))
            loc = FindLevelLoc(p, **fll_kwds)
            lp_map[loc] = -1 # exclude points inside polygon

    # -- size 4
    if size4_bbox is not None:
        loc = FindLevelLoc(size4_bbox, **fll_kwds)
        lp_map[~loc] = -1 # exclude points outsize size-4 bbox

    # -- size 2
    if size2_bbox is not None:
        loc = FindLevelLoc(size2_bbox, **fll_kwds)
        lp_map[loc] = 2

    # -- No size 1 cells within 2 rows to size-changing parallels on the fine
    #    resolution side [to avoid small grid size in high latitudes]
    #    Consequently, we need relax the check rule in these latitudes. So
    #    a prefered level is 4
    #    Warning: when buoys needed to be refined are present in these rows,
    #    some errors will probably be raised. A consistent way to manage these
    #    situations shoulb be achieved in the future. An easy way is that we
    #    only use size 2 cells around buoys
    for jrow in np.arange(0, bathy_obj.nrow):
        jrow_latc = bathy_obj.flat + jrow * bathy_obj.dlat # corner lat
        loc_parmg = np.digitize([jrow,], jparmg)[0] - 1 # [-1 - N-1]
                                            # Maybe impossible to N-1 or -1 ??

        if ((jrow_latc >= 0) and (jrow in jparmg[loc_parmg + 1]+np.array([-2, -1])
           )) or ((jrow_latc <0) and (jrow in jparmg[loc_parmg]+np.array([0, 1]))):
            lp_map[jrow, :] = np.where(np.in1d(lp_map[jrow, :], [1, 2]), 4,
                                       lp_map[jrow, :])
    # -- check lp_map
    tmp = np.ma.masked_equal(lp_map, -1)
    tmp = np.log2(tmp)
    dlr = np.abs(np.diff(tmp, axis=1)) # right - left
    dtb = np.abs(np.diff(tmp, axis=0)) # top - bottom
    con = np.any(dlr > 1) | np.any(dtb > 1)
    assert not con, "The size of SMC cells must increase gradually."

    if debug:
        fig, ax = CartopyMap(proj, coast=True, figsize=(10, 4))
        mappable = plt.pcolormesh(bathy_obj.lon, bathy_obj.lat, lp_map,
                     cmap=cmocean.cm.deep_r, transform=ccrs.PlateCarree())
        plt.colorbar(mappable)

    # -- Intialize an long array to hold cell
    # -- i, j index, xsize, ysize, depth, sx, sy [round depth to nearest integer]
    smcCell = np.empty((ncel_thrd, 7), dtype='l')

    # -- Initialize important vars [count # of cells of each size]
    N1 = 0L # size 1
    N2 = 0L # size 2
    N4 = 0L # size 4
    N8 = 0L # size 8 (not used now)
    NL = 0L # all size

    # -- determine i,j start & end
    # -- [Note: python is 0-based and the end point of arange function is
    # --  excluded]

    # -- Wrap around 360 [only work for global domain]
    ColMax = long(np.rint((360. / bathy_obj.dlon)))

    # -- Begin creating grid
    if debug:
        print '**** [SMCGrid] Creating Grid ****'

    # Initialise smc bounds
    smc_latmin = 999
    smc_lonmin = 999
    central_lonmin = 999
    central_latmin = 999
    smc_latmax = -999
    smc_lonmax = -999
    central_latmax = -999
    central_lonmax = -999

    for jrow in tqdm(np.arange(bathy_obj.jrow_beg, bathy_obj.nrow + bathy_obj.jrow_end + 1 , 4)):
        loc_parmg = np.digitize([jrow,], jparmg)[0] - 1
        ism = 2 ** np.abs(7-loc_parmg)

        jcel = j0 + jrow - bathy_obj.jrow_beg # Important element: jcel
        jrow_latc = bathy_obj.flat + jrow * bathy_obj.dlat # center latitude
        jrow_latsmc = bathy_obj.flat + jrow * bathy_obj.dlat - bathy_obj.dlat/2 # sw corner
        smc_latmin = min(smc_latmin, jrow_latsmc)
        smc_latmax = max(smc_latmax, jrow_latsmc)
        central_latmin = min(central_latmin, jrow_latc)
        central_latmax = max(central_latmax, jrow_latc)

        if debug:
            print '---- lat, jrow, jcel, ism:', jrow_latc, jrow, jcel, ism
            print '.... N1, N2, N4, NL:', N1, N2, N4, NL

        # -- the range of icol is pretty confused [+1 is very important]
        for icol in np.arange(bathy_obj.icol_beg*ism, bathy_obj.ncol + bathy_obj.icol_end*ism + 1,
                              4*ism):

            if np.equal(lp_map[jrow, icol], -1): continue

            icel = i0 + icol - bathy_obj.icol_beg*ism # Important elment: icel
            icol_lonc = bathy_obj.flon + icol * bathy_obj.dlon # center latitude

            # -- Check Neighbor 8 * ism * 8 cells [end point is exclusive]
            jneigh = jrow + np.arange(-2, 6, dtype='l')
            ineigh = np.mod(icol + np.arange(-2*ism, 6*ism, dtype='l')
                            + ColMax, ColMax)
            neigh_cells = bathy_obj.depth[np.ix_(jneigh, ineigh)]
            sea_cells = neigh_cells[np.where(neigh_cells<refining_depth)]
            count_sea = sea_cells.size
            icol_smc = bathy_obj.flon + icol * bathy_obj.dlon - bathy_obj.dlon/2 # sw corner
            if bathy_obj.globe:
                icol_smc %= 360
            smc_lonmin = min(smc_lonmin, icol_smc)
            smc_lonmax = max(smc_lonmax, icol_smc)
            central_lonmin = min(central_lonmin, icol_lonc)
            central_lonmax = max(central_lonmax, icol_lonc)

            if np.equal(count_sea, 8*ism*8) and (lp_map[jrow, icol] >= 4):
                jneigh = jrow + np.arange(0, 4)
                ineigh = np.mod(icol + np.arange(0, 4*ism) + ColMax, ColMax)

                # all the 4*ism*4 cells are sea points
                kdepth = np.rint(-1 * bathy_obj.depth[np.ix_(jneigh, ineigh)].mean())
                kdepth = np.max([kdepth, 5])

                # ksx & ksy
                ksx = np.rint(bathy_obj.sx1[np.ix_(jneigh, ineigh)].mean())
                ksy = np.rint(bathy_obj.sy1[np.ix_(jneigh, ineigh)].mean())

                N4 += 1; NL += 1
                smcCell[NL-1] = [icel, jcel, ism*4, 4, kdepth, ksx, ksy]

                if debug==2:
                    print '.... SMC Cell {:d}'.format(NL), smcCell[NL-1]

            else:
                # -- Check 2 * ism * 2 cells
                for j2 in np.arange(0, 4, 2):
                    for i2 in np.arange(0, 4*ism, 2*ism):
                        # -- two kinds of check
                        # -- 4*ism*4 for interested size 2 area
                        jneigh = jrow + j2 + np.arange(-1, 3)
                        ineigh = np.mod(icol + i2 + np.arange(-1*ism, 3*ism) +
                                        ColMax, ColMax)
                        neigh_cells = bathy_obj.depth[np.ix_(jneigh, ineigh)]
                        sea_cells = neigh_cells[np.where(neigh_cells<refining_depth)]
                        count_sea = sea_cells.size

                        # -- 2*ism*2
                        jneigh = jrow + j2 + np.arange(0, 2)
                        ineigh = np.mod(icol + i2 + np.arange(0, 2*ism) +
                                        ColMax, ColMax)
                        neigh_cells = bathy_obj.depth[np.ix_(jneigh, ineigh)]
                        sea_cells = neigh_cells[np.where(neigh_cells<refining_depth)]
                        count_sea2 = sea_cells.size

                        if count_sea2 == 2*ism*2:
                            kdepth = np.rint(-1 * sea_cells.mean())
                            kdepth = np.max([kdepth, 5])
                            ksx = np.rint(bathy_obj.sx1[np.ix_(jneigh, ineigh)].mean())
                            ksy = np.rint(bathy_obj.sy1[np.ix_(jneigh, ineigh)].mean())

                        if np.equal(count_sea, 4*ism*4) and (
                           lp_map[jrow+j2, icol+i2] >= 2):
                            N2 += 1; NL += 1
                            smcCell[NL-1] = [icel+i2, jcel+j2, ism*2, 2, kdepth,
                                             ksx, ksy]

                            if debug==2:
                                print '.... SMC Cell {:d}'.format(NL
                                      ), smcCell[NL-1]

                        elif np.equal(count_sea2, 2*ism*2) and (
                             lp_map[jrow+j2, icol+i2] >= 4):
                            N2 += 1; NL += 1
                            smcCell[NL-1] = [icel+i2, jcel+j2, ism*2, 2, kdepth,
                                             ksx, ksy]

                            if debug==2:
                                print '.... SMC Cell {:d}'.format(NL
                                      ), smcCell[NL-1]

                        else:
                            # 1) 4ism cells have land points
                            # 2) all 4ism are sea points but lp<=2
                            # -- size 1 cells
                            if ((jrow_latc >= 0 and (jrow+j2) <= jparmg[loc_parmg
                                +1]-2) or (jrow_latc < 0 and (jrow+j2) >=
                                jparmg[loc_parmg]+2)) and (
                                lp_map[jrow+j2, icol+i2] > 0):

                                for j1 in [0, 1]:
                                    for i1 in np.arange(0, 2*ism, ism):
                                        jneigh = jrow + j2 + j1
                                        ineigh = icol + i2 + i1 + np.arange(
                                                 0, ism)
                                        ineigh = np.mod(ineigh + ColMax, ColMax)

                                        neigh_cells = bathy_obj.depth[jneigh, ineigh]
                                        sea_cells = neigh_cells[np.where(neigh_cells<0)]
                                        count_sea = sea_cells.size

                                        if np.equal(count_sea, 1*ism*1):
                                            kdepth = np.rint(-1*sea_cells.mean())
                                            kdepth = np.max([kdepth, 5])
                                            ksx = np.rint(bathy_obj.sx1[jneigh, ineigh].mean())
                                            ksy = np.rint(bathy_obj.sy1[jneigh, ineigh].mean())

                                            N1 += 1; NL += 1
                                            smcCell[NL-1] = [icel+i2+i1,
                                                             jcel+j2+j1,
                                                             ism, 1, kdepth,
                                                             ksx, ksy]

                                            if debug==2:
                                                print '.... SMC Cell {:d}'.format(NL
                                                      ), smcCell[NL-1]

    if bathy_obj.globe and arctic:
        # -- the last four rows
        jrow = bathy_obj.nrow - 4
        # -- ism for the four rows below jrow -- very important
        loc_parmg = np.digitize([jrow-4,], jparmg)[0] - 1
        ism = 2 ** np.abs(7-loc_parmg)

        jcel = j0 + jrow # Important element: jcel
        jrow_latc = bathy_obj.flat + jrow * bathy_obj.dlat

        if debug:
            print '---- Polar Cell lat, jrow, jcel, ism:', jrow_latc, jrow, jcel, ism
            print '.... N1, N2, N4, NL:', N1, N2, N4, NL

        kdepth = np.rint(-bathy_obj.depth[jrow:, :].mean())
        kdepth = np.max([5, kdepth])
        ksx = ksy = 0

        N4 += 1; NL += 1
        # -- What is deltax for the last pole cell
        # -- ncol / # of the size-4 cells in the four rows below the polar cell
        # -- # = ncol / (ism*4)
        xsize = bathy_obj.ncol / (bathy_obj.ncol/(ism * 4))
        smcCell[NL-1] = [0, jcel, xsize, 4, kdepth, ksx, ksy]

    if debug:
        print '**** [SMCGrid] ****'
        print '.... N1, N2, N4, NL:', N1, N2, N4, NL

    smcCell = smcCell[:NL]

    # -- smcCell array --> smcCell Dataframe for easy sorting
    smcCell = pd.DataFrame(smcCell, columns=['i', 'j', 'xsize', 'ysize', 'depth',
                                             'sx', 'sy'])
    smcCell.sort_values(by=['ysize', 'j', 'i'], inplace=True)
    smcCell = np.array(smcCell)

    # -- write to file [cell]
    fmt = '{:10d} '* 5
    header = fmt[:-1].format(NL, N1, N2, N4, N8)
    np.savetxt(bathy_obj.gid.upper()+'Cell.dat', smcCell[:, :5], fmt='%10d',
               header=header, comments='')

    # -- write to file [obstruction]
    fmt = '{:10d} '* 2
    header = fmt[:-1].format(NL, 2)
    np.savetxt(bathy_obj.gid.upper()+'Obs.dat', smcCell[:, 5:], fmt='%10d',
               header=header, comments='')


    # -- write the meta data to a readme file
    with open(bathy_obj.gid.upper()+'.Info', 'w') as f:
        print >>f, '**** [WW3 Grid Inp] ****'
        print >>f, 'globe [Y/N]:', bathy_obj.globe
        print >>f, 'DX, DY:', bathy_obj.ww3_grid['DX'], bathy_obj.ww3_grid['DY']
        print >>f, 'X1, Y1:', bathy_obj.ww3_grid['X1'], bathy_obj.ww3_grid['Y1']
        print >>f, 'NX, NY:', bathy_obj.ww3_grid['NX'], bathy_obj.ww3_grid['NY']
        print >>f, 'XE, YE:', bathy_obj.ww3_grid['XE'], bathy_obj.ww3_grid['YE']
        print >>f
        print >>f, '**** SMC ****'
        print >>f, 'reference point:', refp
        print >>f, 'i0, j0:', i0, j0
        print >>f, 'X1SMC, Y1SMC:', smc_lonmin, smc_latmin
        print >>f, 'XESMC, YESMC:', smc_lonmax, smc_latmax
        print >>f
        print >>f, '**** [WW3 Grid Inp - Reduced Grid] ****'
        print >>f, 'DX, DY:', bathy_obj.ww3_grid['DX'], bathy_obj.ww3_grid['DY']
        print >>f, 'X1, Y1:', smc_lonmin, smc_latmin
        print >>f, 'CX1, CY1:', central_lonmin, central_latmin
        print >>f, 'NX, NY:', (smc_lonmax - smc_lonmin) / bathy_obj.ww3_grid['DX'] + 1, (smc_latmax - smc_latmin) / bathy_obj.ww3_grid['DY'] + 1
        print >>f, 'XE, YE:', smc_lonmax, smc_latmax
        print >>f, 'CXE, CYE:', central_lonmax, central_latmax

    if gen_cell_sides:
        genCellSides(bathy_obj.gid.upper(),
                     bathy_obj.ww3_grid['NY'],
                     bathy_obj.ww3_grid['NX'],
                     bathy_obj.ww3_grid['DY'],
                     bathy_obj.ww3_grid['DX'])

    return smcCell

###############################################################
# -- CartopyMap
def CartopyMap(proj=ccrs.Robinson(central_longitude=180.), resolution='50m', gridbase=10, land=False,
               coast=True, nrows=1, ncols=1, **fig_kw):
    """
    Create a map by Cartopy

    set_extent does not work for lambert projection

    Input args:
    -----------
        proj -- one specific projection supported by Cartopy

        resolution -- the resolution of coastline, `100m`, `50m` or `10m`

        fig -- figure object

        gridbase -- draw gridlines on multiple*gridbase

        land -- fill land or not

        coast -- draw coastline or not
    """
    fig, axs = plt.subplots(nrows=nrows, ncols=ncols,
                            subplot_kw=dict(projection=proj), **fig_kw)

    if nrows * ncols == 1: axs = np.array([axs,])

    # -- fill land & coastline
    if land:
        LAND = cfeature.NaturalEarthFeature('physical', 'land', resolution,
                                            edgecolor='face',
                                            facecolor=cfeature.COLORS['land'])
        for ax in axs:
            ax.add_feature(LAND, facecolor='.75')

    if coast:
        for ax in axs:
            ax.coastlines(resolution, linewidth=.5)

    # -- gridlines
    for ax in axs:
        gl = ax.gridlines(color='.5', linewidth=0.4, linestyle='-')
        gl.xlocator = mticker.MultipleLocator(gridbase)
        gl.ylocator = mticker.MultipleLocator(gridbase)

    if nrows * ncols == 1: axs = axs[0]

    return fig, axs

###############################################################
# -- Class UnSMC
class UnSMC(object):
    """
    UnSMC [Unstructured SMC grid/cell]

    For simplicity, we only get SMC cells from a specific file, which is
    arranged as follows:
        NL N1 N2 N4 N8
        i j xsize ysize depth [sx, sy, wave parms]

    Input args:
    -----------
        fnm -- filename/path of smcCell

        dlon & dlat -- resolution of size-1 cell [transform points]

        refp -- refp point

        proj -- cartopy projection
                for global smc grid, please do not use the arg
    """
    def __init__(self, fnm, dlon=None, dlat=None, refp=None, proj=None):
        # -- header
        with open(fnm) as f:
            header = np.array(f.readline().strip().split()).astype('l')
            #(self.NL, self.N1, self.N2, self.N4) = header
            (self.NL, self.N1, self.N2, self.N4, self.N8) = header

        # -- contents
        smc_df = pd.read_csv(fnm, sep='\s+', skiprows=1, dtype=np.int64,
                             names=['i', 'j', 'xsize', 'ysize', 'depth'])

        # -- assign each column to self
        for name in smc_df.columns:
            setattr(self, name, smc_df[name])

        # -- dlon & dlat & gid
        self.dlon, self.dlat = dlon, dlat
        self.gid = os.path.splitext(os.path.basename(fnm))[0]
        self.refp = refp
        self.proj = proj

    def _genPoly(self):
        """
        Generate PolyCollection for further plotting.
            xvert, yvert, clat, clon --> poly vertices
        """
        rx, ry = self.refp

        # -- sw corner lat/lon
        self.sw_lon = self.i * self.dlon + rx
        self.sw_lat = self.j * self.dlat + ry

        # -- center lon/lat
        self.clon = self.sw_lon + self.xsize * self.dlon * 0.5
        self.clat = self.sw_lat + self.ysize * self.dlat * 0.5

        # -- edges [nl * 4]
        xvert = np.c_[self.sw_lon, self.sw_lon+self.xsize*self.dlon,
                      self.sw_lon+self.xsize*self.dlon, self.sw_lon,]

        yvert = np.c_[self.sw_lat, self.sw_lat, self.sw_lat+self.ysize*self.dlat,
                      self.sw_lat+self.ysize*self.dlat]

        self.poly = np.zeros((self.NL, 4, 2)) # nl * 4 * 2
        self.poly[:, :, 0] = xvert # longitude
        self.poly[:, :, 1] = yvert # latitude

        # -- seems not necessary
        # -- transform lon/lat to map
        # -- although PolyCollection accepts a keyword `transform`, we
        # -- undertake the transformation explicitly for performance
        if self.proj is not None:
            points1d = self.poly.ravel()
            # -- points_map [npntsx3]
            points_map = self.proj.transform_points(ccrs.PlateCarree(),
                                                    points1d[0::2], # x
                                                    points1d[1::2]) # y
            self.poly[..., 0] = points_map[:, 0].reshape(self.NL, 4)
            self.poly[..., 1] = points_map[:, 1].reshape(self.NL, 4)

    def readVar(self, fnm, var=None):
        """
        readVar

        Add other var (like wave parameters) from fnm [generated by propagating
        test]
        """
        with open(fnm) as f:
            self.time, nc = np.array(f.readline().strip().split(), dtype='l')
            assert nc == self.NL, 'readVar: No. of Cells does not match'

            beg = 0
            vararr = np.empty(nc, dtype='d')
            conts = f.readlines()
            for line in conts:
                lnstr = line.strip().split()
                nelm = len(lnstr)
                if nelm == 0: continue

                vararr[beg: beg+nelm] = np.array(lnstr).astype('d')

                beg = beg+nelm

        setattr(self, var, pd.Series(vararr, index=self.i.index))

    def readObs(self, fnm):
        """
        readObs

        Read obstruction file
        """
        with open(fnm) as f:
            header = f.readline().strip().split()
            nc = long(header[0])
            assert nc == self.NL, 'readObs: No. of Cells does not match'

        arr = np.loadtxt(fnm, skiprows=1)
        self.sx = pd.Series(arr[:, 0], index=self.i.index)
        self.sy = pd.Series(arr[:, 1], index=self.i.index)

    def genPlot(self, ax=None, filled=False, plot_var=None,
                cax_kws=None, cb_kws=None, txtloc=None,
                center=False, dotsize=0.008, mapext=None,
                vmin=None, vmax=None, vint=None, txtSize=7, cbtxtSize=None):
        """
        Generate plot for plot_var on SMC grid

        Input args:
        -----------
            ax -- axis object
            filled -- fill cells or not
            plot_var -- the parameter need to be plotted, of which valules
                        determine the filled color
            cax_kws -- kws for colorbar location
            cb_kwds -- kws for colobar
            txtloc -- loc of necessary text info. (x, y)
            center -- draw dots in each cell
            dotsize -- the radius of Circles (for cell center dots)
            mapext -- map bbox to zoom in the cartopy map
            vmin/vmax/vint -- colorbar range/tick
        """
        if not hasattr(self, 'poly'):
            self._genPoly()

        # -- plot setting
        if plot_var.lower() == 'depth':
            filled = False
            norm = mpl.colors.LogNorm(vmin=1, vmax=10000, clip=False)
            cmap = gen_cmap(cmap='SMC', end=128, reverse=True, ncols=256, color=False)
            cbtl = 'Depth [m]'
            cticks = [1, 10, 100, 1000, 10000]

        elif plot_var.lower() == 'swh':
            if vmin is None: vmin = 0.
            if vmax is None: vmax = 6.
            if vint is None: vint = 1.
            filled = True
            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax, clip=False)
            cmap = gen_cmap(cmap='jet', color=False)
            cbtl = 'SWH [m]'
            cticks = np.arange(vmin, vmax+.1*vint, vint)

        elif plot_var.lower() == 'sx' or plot_var.lower() == 'sy':
            filled = True
            norm = mpl.colors.Normalize(vmin=0., vmax=100., clip=False)
            cmap = gen_cmap(cmap='YlOrRd', white=0, ncols=256, color=False)
            cbtl = 'Obs. in {:s} dirc. [%]'.format(plot_var.lower()[1])
            cticks = np.arange(0, 101, 20)

        elif plot_var.lower() == 'wspd':
            filled = True
            vmax = vmax if vmax else 40
            vmin = vmin if vmin else 0.
            vint = vint if vint else 10.
            cmap = gen_cmap(cmap='plasma', color=False)
            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax, clip=False)
            cbtl = 'Wind [m/s]'
            cticks = np.arange(vmin, vmax+.1*vint, vint)

        else:
            pass

        facecolor = None if filled else 'none'

        # -- cells
        if self.proj is not None:
            polyc = PolyCollection(self.poly, cmap=cmap, norm=norm, linewidth=0.1,
                                   facecolor=facecolor)
        else:
            polyc = PolyCollection(self.poly, cmap=cmap, norm=norm, linewidth=0.1,
                                   facecolor=facecolor, transform=ccrs.PlateCarree())
        polyc.set_edgecolor('face')
        polyc.set_array(getattr(self, plot_var))
        ax.add_collection(polyc)

        # -- center dot of each cell
        # -- use 'o' or 's' to replace '.'
        if center: # use very small size for scatter/marker
            ax.scatter(self.clon, self.clat, s=dotsize, c=getattr(self, plot_var),
                       marker='o', norm=norm, cmap=cmap, edgecolor='none',
                       transform=ccrs.PlateCarree())

#            circlec = PatchCollection([Circle((x, y), radius=radius)
#                                       for x, y in np.c_[self.clon, self.clat]],
#                                      edgecolor='none', cmap=cmap, norm=norm,
#                                      transform=ccrs.PlateCarree())
#            circlec.set_array(getattr(self, plot_var))
#            ax.add_collection(circlec)

        # -- lim axis
        ax.autoscale_view() # !!! Very important

        if mapext is not None:
            ax.set_extent(mapext, crs=ccrs.PlateCarree())

        # -- colorbar
        if cax_kws is None: cax_kws = dict()
        btr = None if cax_kws.get('bbox_to_anchor') is None else ax.transAxes

        cax = inset_axes(ax,
                         width=cax_kws.get('width', '40%'),
                         height=cax_kws.get('height', '3%'),
                         loc=cax_kws.get('loc', 2), # upper right
                         bbox_to_anchor=cax_kws.get('bbox_to_anchor', None),
                         bbox_transform=btr,
                         borderpad=cax_kws.get('borderpad', None))  # units: fontsize
                         #borderpad=cax_kws.get('borderpad', 2.))  # units: fontsize

        if cb_kws is None: cb_kws=dict()
        cb = plt.colorbar(polyc, cax=cax, format='%d',
                          orientation=cb_kws.get('orientation', 'horizontal'))
        cb.set_label(cbtl, size=txtSize)
        cb.set_ticks(cticks)
        if cbtxtSize is None: cbtxtSize = txtSize - 1
        cb.ax.tick_params(labelsize=cbtxtSize)

        # -- cell info.
        if plot_var in ['depth', 'sx', 'sy']:
            info = ('{:s}\n'
                    r'$\longmapsto$'
                    '\n  NL = {:d}\n  N1 = {:d}\n  N2 = {:d}\n  N4 = {:d}').format(
                    self.gid, self.NL, self.N1, self.N2, self.N4)

        if plot_var in ['swh', 'wspd']:
            try:
                timeStr = self.time.strftime('%Y-%m-%d %HZ')
            except:
                timeStr = str(self.time)

            info = '{:s}\n    Max: {:.1f}\n    Min: {:.1f}'.format(
                    timeStr, getattr(self, plot_var).max(), getattr(self, plot_var).min())

        if txtloc is None: txtloc = (0.1, 0.85)
        ax.text(txtloc[0], txtloc[1], info, ha='left',
                va='top', multialignment='left', transform=ax.transAxes,
                fontsize=txtSize, color=ct10[3])

def genCellSides(gid, nlat, nlon, dlat, dlon):
    """
    genCellSides

    Generate cell sides using wrapped fortran code
    ----
    Input args:
        gid - Grid id
        nlat, nlon - lat/lon dimensions of grid
    """
    from  SMCPy.fortran.GenCellSide import gencellside
    gencellside.adapgrid(gid, nlat, nlon, dlat, dlon)
    # gencellside.cellside(gid)
    print "Sorting face arrays..."
    SortFaceArray(gid+'ISide.d', gid+'JSide.d')

#        return ax

###############################################################
# -- SortFaceArray
def SortFaceArray(ufnm, vfnm):
    """
    SortFaceArray

    Sort U face array and V face array
    ----
    Input args:
        ufnm & vfnm -- fnm of unsorted face/side array
    """
    uSide = pd.read_csv(ufnm, header=None, sep='\s+',
                        names=['i','j', 'ysize', 'll', 'l', 'r', 'rr'])

    vSide = pd.read_csv(vfnm, header=None, sep='\s+',
                        names=['i','j', 'xsize', 'bb', 'b', 't', 'tt', 'ysize'])

    for fnm, Side in zip([ufnm, vfnm], [uSide, vSide]):
        Side.sort_values(by=['ysize', 'j', 'i'], inplace=True)

        NS = Side['ysize'].size
        N1 = np.equal(Side['ysize'], 1).sum()
        N2 = np.equal(Side['ysize'], 2).sum()
        N4 = np.equal(Side['ysize'], 4).sum()
        N8 = np.equal(Side['ysize'], 8).sum()

        fnm = fnm.replace('.d', '.dat')
        fmt = '{:10d} '* 5
        header = fmt[:-1].format(NS, N1, N2, N4, N8)
        np.savetxt(fnm, np.array(Side), fmt='%10d', header=header, comments='')

###############################################################
# -- WW3SMC
class WW3SMC(UnSMC):
    def __init__(self, cellFnm=None, dlon=None, dlat=None, refp=None):
        super(WW3SMC, self).__init__(fnm=cellFnm, dlon=dlon, dlat=dlat, refp=refp)

    def readWW3(self, ww3Fnm):
        """
        Read ww3Fnm

        To do [support more components]
        """
        # -- header [time, sclFac, var]
        with open(ww3Fnm) as f:
            print '**** Reading {:s} ****'.format(ww3Fnm)
            header = f.readline().strip().split()
            self.time = datetime.datetime.strptime(header[2] + header[3],
                                                   '%Y%m%d%H%M%S')
            ncel = int(header[4])
            ndim = int(header[5])
            sclFac = float(header[6])
            fext = header[7]

            assert ncel == self.NL, ('# of sea points do not agree with the'
                                     ' bathy file')

            varArr = np.zeros(self.NL*ndim, dtype='d')

            beg = 0
            conts = f.readlines()
            for line in conts:
                lnstr = line.strip().split()
                nelm = len(lnstr)
                if nelm == 0: continue

                varArr[beg: beg+nelm] = np.array(lnstr).astype('d')
                beg = beg+nelm

#            varArr *= sclFac
        if ndim > 1:
            varArr = np.reshape(varArr, (ndim, self.NL))

        if fext == '.hs':
            self.swh = varArr
        elif fext == '.wnd':
            self.u10 = varArr[0]
            self.v10 = varArr[1]
            self.wspd = np.sqrt(self.u10**2. + self.v10**2.)

        del varArr

###############################################################
